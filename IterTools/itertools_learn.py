import operator
import itertools
from itertools import product
import string
from itertools import permutations
from itertools import combinations
from itertools import combinations_with_replacement

"""
Different types of iterators provided by this module are: 

1.Infinite iterators
2.Combinatoric iterators:
    The recursive generators that are used to simplify combinatorial constructs such as permutations, combinations, and Cartesian products
     are called combinatoric iterators.
    Product,Permutation,
3.Terminating iterators:Terminating iterators are used to work on the short input sequences and produce the output based on the functionality of the method used.
accumulate


"""


def count_itertools(a: int, b: int):
    """
    count(start, step): This iterator starts printing from the “start” number and prints infinitely. 
    If steps are mentioned, the numbers are skipped else step is 1 by default. 
    See the below example for its use with for in loop.
    """
    #print("Printing to just check whether it would take some argument or not",a)
    for i in itertools.count(a, b):
        if (i == 14):
            break
        print(i)


def cycle_itertools(str: string)->None:
    """
    cycle(iterable): This iterator prints all values in order from the passed container.
    It restarts printing from the beginning again when all elements are printed in a cyclic manner.
    """
    count = 0
    for i in itertools.cycle(str):

        if count > 7:
            break
        else:
            print(i)
            count += 1


def cycle_itertools_next(li: list)->None:
    """
    Next function which takes next value of iterable.
    """
    itr = itertools.cycle(li)
    for _ in range(12):
        print(next(itr))


def cycle_itertools_repeat(a: int, b: int)->None:
    """
    repeat(val, num): This iterator repeatedly prints the passed value an infinite number of times. 
    If the optional keyword num is mentioned, then it repeatedly prints num number of times
    """
    print("Printing numbers repepatedely")
    print(list(itertools.repeat(a, b)))

def product_itertools(li:list,str:string):
    """
    This tool computes the cartesian product of input iterables.
    To compute the product of an iterable with itself, we use the optional repeat keyword argument to specify the number of repetitions.
    The output of this function is tuples in sorted order.
    """
    print(list(product(li,str)))

def permutation_itertools():
    """
    Permutations() as the name speaks for itself is used to generate all possible permutations of an iterable.
    All elements are treated as unique based on their position and not their values. 
    This function takes an iterable and group_size, if the value of group_size is not specified or is equal to None then the value of group_size becomes the length of the iterable
    """
    print ("All the permutations of the given list is:") 
    print (list(permutations([1, 'geeks'], 2)))
  
   
    print ("All the permutations of the given string is:") 
    print (list(permutations('Vinit')))
    
    
    print ("All the permutations of the given container is:") 
    print(list(permutations(range(6), 3)))

def combinations_itertools():
    """
    This function returns a subsequence of length n from the elements of the iterable where n is the argument that the function takes determining the length of the subsequences generated by the function.
    Individual elements may repeat itself in combinations_with_replacement function.
    """
    print ("All the combination of list in sorted order(without replacement) is:") 
    print(list(combinations(['A', 2], 2)))
    print()
    
    print ("All the combination of string in sorted order(without replacement) is:")
    print(list(combinations('AB', 2)))

    print ("All the combination of string in sorted order(with replacement) is:")
    print(list(combinations_with_replacement("AB", 2)))


def accumulate_itertools():
    """
    This iterator takes two arguments, iterable target and the function which would be followed at each iteration of value in target. 
    If no function is passed, addition takes place by default.
    If the input iterable is empty, the output iterable will also be empty.
    """
    print("Accumultor Function")
    lis=[1,4,5,10,20]
    print(list(itertools.accumulate(lis)))
    print("Acculate after  Multiplication")
    print(list(itertools.accumulate(lis,operator.mul)))


def chain_itertools():
    """
    This function is used to print all the values in iterable targets one after another mentioned in its arguments.
    """
    li1 = [1, 4, 5, 7]
   
    # initializing list 2
    li2 = [1, 6, 5, 9]
    
    # initializing list 3
    li3 = [8, 10, 5, 4]
    
    # using chain() to print all elements of lists
    print ("All values in mentioned chain are : ", end ="")
    print (list(itertools.chain(li1, li2, li3)))


if __name__ == "__main__":
    # count_itertools(2,2)
    # cycle_itertools("AB")
    # cycle_itertools_next(["Geeks","For","Geeks"])
    # cycle_itertools_repeat(25, 7)
    #product_itertools([3,4,2],"A")
    #product_itertools(['geeks', 'for', 'geeks'], '2')
    #permutation_itertools()
    accumulate_itertools()
